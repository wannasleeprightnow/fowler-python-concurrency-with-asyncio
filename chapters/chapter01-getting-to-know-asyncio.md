# 1.1 Что такое asyncio?

asyncio появился в python3.4. она включала декораторы и синтаксис генератора yield from для определения сопрограмм.

**Сопрограмма** - метод, который можно приостановить, если есть потенциально длительная задача, а затем возобновить, когда она завершится.

В python3.5 добавлен синтаксис async/await.

asyncio для исполнения программ асинхронно использует модель конкуренции **однопоточный цикл событий.**

# 1.2 Что такое ограниченность производительностью ввода-вывода и ограниченность быстродействием процессора

![](/images/chapter01/image01-operations-limited-by-io-and-cpu.png)

Асинхронный ввод-вывод позволил бы приостановить выполнение метода при наличии IO; ожидая его завершения в фоне, выполнялся бы другой код. Это позволяет ускорять работы приложения.

# 1.3 Конкурентность, параллелизм и многозадачность

Конкурентность != параллелизм

![](/images/chapter01/image02-concurrency-and-parallelism.png)

*Рис. 1.2 В случае конкурентности мы переключаемся между двумя
приложениями. В случае параллелизма мы активно выполняем два приложения
одновременно*

Конкуренстность можно организовать и на одном ядре, используя **вытеснующую многозадачность** для переключения между задачами.

Параллелизм подразумевает конкуренстность, но обратное верно не всегда.

Вытесняющая многозадачность: **ОС переключает между задачами** при помощи процедуры квантования времени. Используется либо несколько потоков, либо несколько процессов.

Кооперативная многозадачность: **переключения явно объясляются в коде**, т.е. исполняемые задачи кооперируются.

Кооперативная многозадачность используется в asyncio - мы явно помечаем в коде места, в которой приложение может подождать результат, а покаа будет исполняться другой код.
Такое выполнение не является параллельным.

Преимущества кооперативной многозадачности над вытесняющей:

 - Потребление меньшего количества ресурсов. Для переключения между потоками или процессами необходимо произвести **контекстное переключение**(для сохранения контекста), а это трудоемкая операция.
 - Гранулярность. ОС приостанавливает поток или процесс не в самый оптимальный момент, явно помечать точки выгоднее.

# 1.4 Процессы, потоки, многопоточность и многопроцессность

**Процесс** - работающее приложение, для которого выделена область памяти, недоступная другим приложениям. Если на машине одно ядро, то процессы могут работать конкурентно при помощи квантования времени, если несколько - одновременно.

**Поток** можно представлять как облегченный процесс.

 - Наименьшая единица, которая может управляться ОС
 - Асоциирован с процессом, создавшим его
 - Использует память процесса, с которым ассоциирован
 - **С каждым процессом ассоциирован минимум один поток - главный**
 - Останые потоки называются фоновыми

Демонстрация главного потока:

```python
import os
import threading

print(f'Исполняется Python-процесс с идентификатором: {os.getpid()}')

total_threads = threading.active_count()
thread_name = threading.current_thread().name

print(f'В данный момент Python исполняет {total_threads} поток(ов)')
print(f'Имя текущего потока {thread_name}')
```
*Листинг 1.2 Процессы и потоки в простом Python-приложении*

```
Исполняется Python-процесс с идентификатором: 98230
В данный момент Python исполняет 1 поток(ов)
Имя текущего потока MainThread
```

**Многопоточность** - конкурентное выполнение работы фоновыми потоками процесса.

```python
import threading


def hello_from_thread():
    print(f'Привет от потока {threading.current_thread()}!')


hello_thread = threading.Thread(target=hello_from_thread)
hello_thread.start()

total_threads = threading.active_count()
thread_name = threading.current_thread().name

print(f'В данный момент Python выполняет {total_threads} поток(ов)')
print(f'Имя текущего потока {thread_name}')

hello_thread.join()
```
*Листинг 1.3 Создание многопоточного Python-приложения*

```
Исполняется Python-процесс с идентификатором: 98230
В данный момент Python исполняет 1 поток(ов)
Имя текущего потока MainThread
```

join приостанавливает программу до тех пор, пока поток не завершится.

![](/images/chapter01/image03-a-multithreaded-program-with-two-workers-and-one-main-thread.png)

*Рис. 1.4 Многопоточная программа с двумя рабочими и одним главным потоком. Все они разделяют общую память с процессом*

Многопоточность в python подходит только для IO задач, поскольку мешает GIL, но в других языках это обычный способ реализации конкурентности.

**Многопроцессность** - создание дочерних конкурентных процессов, которыми управляет родительский. В python для этого используется модуль multiprocessing.

```python
import multiprocessing
import os


def hello_from_process():
    print(f'Привет от дочернего процесса {os.getpid()}!')


if __name__ == '__main__':
    hello_process = multiprocessing.Process(target=hello_from_process)
    hello_process.start()
    print(f'Привет от родительского процесса {os.getpid()}')
    hello_process.join()
```
*Листинг 1.4 Создание нескольких процессов*

```
Привет от родительского процесса 12166
Привет от дочернего процесса 12388!
```

Многопроцессность предпочительна в cpu-bound задачах.


![](/images/chapter01/image04-app-that-has-one-parent-process-and-two-child-processes.png)

*Рис. 1.5 Приложение, в котором имеется один родительский процесс
и два дочерних*