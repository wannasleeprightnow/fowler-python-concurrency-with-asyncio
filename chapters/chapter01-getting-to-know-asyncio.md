# 1.1 Что такое asyncio?

`asyncio` появился в Python 3.4.  
Она включала декораторы и синтаксис генератора `yield from` для определения сопрограмм.

**Сопрограмма** — метод, который можно приостановить, если есть потенциально длительная задача, а затем возобновить, когда она завершится.

В Python 3.5 добавлен синтаксис `async/await`.

`asyncio` для исполнения программ асинхронно использует модель конкуренции — **однопоточный цикл событий**.

---

# 1.2 Что такое ограниченность производительностью ввода-вывода и ограниченность быстродействием процессора

![](/images/chapter01/image01-operations-limited-by-io-and-cpu.png)

Асинхронный ввод-вывод позволяет приостановить выполнение метода при наличии IO; ожидая его завершения в фоне, выполняется другой код. Это позволяет ускорить работу приложения.

---

# 1.3 Конкурентность, параллелизм и многозадачность

Конкурентность ≠ параллелизм

![](/images/chapter01/image02-concurrency-and-parallelism.png)

*Рис. 1.2. В случае конкурентности мы переключаемся между двумя
приложениями. В случае параллелизма мы активно выполняем два приложения
одновременно.*

Конкурентность можно организовать и на одном ядре, используя **вытесняющую многозадачность** для переключения между задачами.

Параллелизм подразумевает конкурентность, но обратное верно не всегда.

**Вытесняющая многозадачность** — ОС переключает между задачами при помощи процедуры квантования времени. Используются либо несколько потоков, либо несколько процессов.

**Кооперативная многозадачность** — переключения явно описываются в коде, то есть исполняемые задачи кооперируются.

Кооперативная многозадачность используется в `asyncio` — мы явно помечаем в коде места, где приложение может подождать результат, а пока будет исполняться другой код.  
Такое выполнение не является параллельным.

**Преимущества кооперативной многозадачности над вытесняющей:**

- Меньшее потребление ресурсов. Для переключения между потоками или процессами необходимо произвести **контекстное переключение**, что является трудоёмкой операцией.  
- Гранулярность. ОС приостанавливает поток или процесс не всегда в оптимальный момент, поэтому явно помечать точки переключения выгоднее.

---

# 1.4 Процессы, потоки, многопоточность и многопроцессность

**Процесс** — работающее приложение, для которого выделена область памяти, недоступная другим приложениям. Если на машине одно ядро, процессы могут работать конкурентно при помощи квантования времени; если несколько — одновременно.

**Поток** можно рассматривать как облегчённый процесс.

- Наименьшая единица, управляемая ОС  
- Ассоциирован с процессом, создавшим его  
- Использует память процесса, с которым связан  
- **С каждым процессом ассоциирован минимум один поток — главный**  
- Остальные потоки называются фоновыми  

Демонстрация главного потока:

```python
import os
import threading

print(f'Исполняется Python-процесс с идентификатором: {os.getpid()}')

total_threads = threading.active_count()
thread_name = threading.current_thread().name

print(f'В данный момент Python исполняет {total_threads} поток(ов)')
print(f'Имя текущего потока {thread_name}')
```
*Листинг 1.2. Процессы и потоки в простом Python-приложении*

```
Исполняется Python-процесс с идентификатором: 98230
В данный момент Python исполняет 1 поток(ов)
Имя текущего потока MainThread
```

**Многопоточность** — конкурентное выполнение работы фоновыми потоками процесса.

```python
import threading


def hello_from_thread():
    print(f'Привет от потока {threading.current_thread()}!')


hello_thread = threading.Thread(target=hello_from_thread)
hello_thread.start()

total_threads = threading.active_count()
thread_name = threading.current_thread().name

print(f'В данный момент Python выполняет {total_threads} поток(ов)')
print(f'Имя текущего потока {thread_name}')

hello_thread.join()
```
*Листинг 1.3. Создание многопоточного Python-приложения*

```
Исполняется Python-процесс с идентификатором: 98230
В данный момент Python исполняет 1 поток(ов)
Имя текущего потока MainThread
```

`join` приостанавливает программу до тех пор, пока поток не завершится.

![](/images/chapter01/image03-a-multithreaded-program-with-two-workers-and-one-main-thread.png)

*Рис. 1.4. Многопоточная программа с двумя рабочими и одним главным потоком. Все они разделяют общую память с процессом.*

Многопоточность в Python подходит только для IO-задач, поскольку мешает GIL, но в других языках это обычный способ реализации конкурентности.

**Многопроцессность** — создание дочерних конкурентных процессов, которыми управляет родительский. В Python для этого используется модуль `multiprocessing`.

```python
import multiprocessing
import os


def hello_from_process():
    print(f'Привет от дочернего процесса {os.getpid()}!')


if __name__ == '__main__':
    hello_process = multiprocessing.Process(target=hello_from_process)
    hello_process.start()
    print(f'Привет от родительского процесса {os.getpid()}')
    hello_process.join()
```
*Листинг 1.4. Создание нескольких процессов*

```
Привет от родительского процесса 12166
Привет от дочернего процесса 12388!
```

Многопроцессность предпочтительна в CPU-bound задачах.

![](/images/chapter01/image04-app-that-has-one-parent-process-and-two-child-processes.png)

*Рис. 1.5. Приложение, в котором имеется один родительский процесс и два дочерних.*

---

# 1.5 Глобальная блокировка интерпретатора

GIL не позволяет интерпретатору выполнять более одной команды байт-кода за раз, за исключением многопроцессных приложений, так как на каждый процесс приходится свой интерпретатор.

GIL необходим, поскольку **garbage collector** подсчитывает количество ссылок на каждую переменную и удаляет её, если счётчик равен нулю. В случае с несколькими потоками количество ссылок может меняться непредсказуемо.

**Состояние гонки** — изменение одних и тех же данных несколькими потоками одновременно.

![](/images/chapter01/image05-race-condition-with-link-counter.png)

*Рис. 1.6. Состояние гонки, когда два потока одновременно увеличивают счётчик ссылок.*

На CPU-bound задачи с использованием многопоточности уходит даже больше времени, поскольку требуется создавать и управлять потоками.

GIL не блокируется на время IO-операций, поскольку для них требуются низкоуровневые системные вызовы, которые работают вне среды Python. Это позволяет освободить GIL. Он захватывается снова, когда данные возвращаются в Python.

При работе с `asyncio` мы используем сопрограммы и факты освобождения GIL при IO-операциях.

---

# 1.6 Как работает однопоточная конкурентность

**Сокет** — низкоуровневая абстракция отправки и получения данных по сети.

Основные операции:
- Получение байтов  
- Отправка байтов

![](/images/chapter01/image06-reading-and-writing-bytes-from-socket.png)

*Рис. 1.7. Запись и чтение байтов из сокета.*

**По умолчанию сокеты блокирующие. Но на уровне ОС можно работать с ними в фоне, уведомляя о получении данных.**

Системы уведомления, абстрагируемые `asyncio`:
- kqueue (FreeBSD, macOS)  
- epoll (Linux)  
- IOCP (Windows)

![](/images/chapter01/image07-non-blocking-socket.png)

*Рис. 1.8. После записи запроса в неблокирующий сокет управление возвращается немедленно, а ОС начинает наблюдать за данными в сокете. Поэтому функция `execute_other_code()` начинает выполняться сразу, не дожидаясь завершения операции ввода-вывода. Когда операция завершится, мы получим уведомление и сможем обработать ответ.*

---

# 1.7 Как работает цикл событий?

```python
from collections import deque

messages = deque()
while True:
    if messages:
        message = messages.pop()
        process_message(message)
```

Базовый цикл событий содержит лишь список событий и бесконечный цикл, в котором они выполняются.

Задача в `asyncio` — обёртка вокруг сопрограммы.

При создании цикла событий создаётся пустой список задач и запускается бесконечный цикл.

Если есть готовая задача, она выполняется до встречи с IO-операцией. Тогда она приостанавливается, ОС следит за сокетами, а цикл переходит к следующей задаче.

![](/images/chapter01/image08-example-thread-of-tasks.png)

*Рис. 1.9. Пример потока, поставляющего задачи циклу событий.*

![](/images/chapter01/image09-concurrency-execution.png)

*Рис. 1.10. Конкурентное выполнение задач с IO-операциями.*
